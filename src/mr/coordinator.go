package mr

import (
	"fmt"
	"log"
	"sync"
	"time"
)
import "net"
import "os"
import "net/rpc"
import "net/http"

type Coordinator struct {
	// Your definitions here.
	inputFiles []string
	nReduce    int

	mapTasks    []MapReduceTask
	reduceTasks []MapReduceTask

	// Increase by 1 when one mapTask done. The map Phase is done when mapDone == inputFiles
	mapDone int
	// Increase by 1 when one reduceTask done. The reduce Phase is done when reduceDone == nReduce
	reduceDone int

	// Each time allow one work to update
	mutex sync.Mutex
}

// Your code here -- RPC handlers for the worker to call.

// an example RPC handler.
//
// the RPC argument and reply types are defined in rpc.go.
func (c *Coordinator) Example(args *ExampleArgs, reply *ExampleReply) error {
	reply.Y = args.X + 1
	return nil
}

func (c *Coordinator) NotifyComplete(arg *RequestTaskReply, reply *RequestTaskReply) error {
	c.mutex.Lock()
	defer c.mutex.Unlock()

	fmt.Println("Completed Task, ", arg)

	// We will mark the task as complete
	if arg.Task.Task == Map {
		c.mapTasks[arg.TaskNo] = arg.Task
	} else if arg.Task.Task == Reduce {
		c.reduceTasks[arg.TaskNo] = arg.Task
	}

	return nil
}

func (c *Coordinator) RequestTask(args *RequestTaskReply, reply *RequestTaskReply) error {
	c.mutex.Lock()
	defer c.mutex.Unlock()

	// Check if all the map tasks are done
	if c.mapDone < len(c.inputFiles) {
		reply.TaskNo = c.mapDone
		reply.Task = c.mapTasks[c.mapDone]
		reply.Task.Status = Assigned
		reply.NReduce = c.nReduce

		c.mapDone++
		return nil
	}

	for index, mapTask := range c.mapTasks {
		// Before this, we need to ensure that the map task is completed
		if mapTask.Status != Finished {
			reply.TaskNo = index
			reply.Task = c.mapTasks[index]
			reply.Task.Status = Assigned
			reply.NReduce = c.nReduce
			return nil
		}
	}

	// Check if all reduce tasks are done
	if c.reduceDone < c.nReduce {
		reply.TaskNo = c.reduceDone
		reply.Task = c.reduceTasks[c.reduceDone]
		reply.Task.Status = Assigned
		reply.NReduce = c.nReduce

		c.reduceDone++
		return nil
	}

	// Iterate through all the tasks of reduce
	for index, reduceTask := range c.reduceTasks {
		if reduceTask.Status != Finished {
			reply.TaskNo = index
			reply.Task = c.reduceTasks[index]
			reply.Task.Status = Assigned
			reply.NReduce = c.nReduce

			return nil
		}
	}

	reply.Task.Status = Status(Wait)
	return nil
}

// start a thread that listens for RPCs from worker.go
func (c *Coordinator) server() {
	rpc.Register(c)
	rpc.HandleHTTP()
	//l, e := net.Listen("tcp", ":1234")
	sockname := coordinatorSock()
	os.Remove(sockname)
	l, e := net.Listen("unix", sockname)
	if e != nil {
		log.Fatal("listen error:", e)
	}
	go http.Serve(l, nil)
}

// Done
// main/mrcoordinator.go calls Done() periodically to find out
// if the entire job has finished.
func (c *Coordinator) Done() bool {
	c.mutex.Lock()
	defer c.mutex.Unlock()

	// iterate map tasks and reduce tasks
	for _, mapTask := range c.mapTasks {
		if mapTask.Status != Finished {
			return false
		}
	}

	for _, reduceTask := range c.reduceTasks {
		if reduceTask.Status != Finished {
			return false
		}
	}

	return true
}

// MakeCoordinator
// create a Coordinator.
// main/mrcoordinator.go calls this function.
// nReduce is the number of reduce tasks to use.
func MakeCoordinator(files []string, nReduce int) *Coordinator {
	c := Coordinator{
		inputFiles:  files,
		nReduce:     nReduce,
		mapTasks:    make([]MapReduceTask, len(files)),
		reduceTasks: make([]MapReduceTask, nReduce),
		mapDone:     0,
		reduceDone:  0,
		mutex:       sync.Mutex{},
	}

	// Initialize mapTasks
	for i := range c.mapTasks {
		c.mapTasks[i] = MapReduceTask{
			Task:        Map,
			Status:      Unassigned,
			TimeStamp:   time.Now(),
			Index:       i,
			InputFiles:  []string{files[i]}, // Assign input file for map task
			OutputFiles: nil,                // Output files will be generated after the map task is completed
		}
	}

	// Initialize reduceTasks
	for i := range c.reduceTasks {
		c.reduceTasks[i] = MapReduceTask{
			Task:        Reduce,
			Status:      Unassigned,
			TimeStamp:   time.Now(),
			Index:       i,
			InputFiles:  generateInputFiles(i, len(files)),     // Input files will be generated by map tasks
			OutputFiles: []string{fmt.Sprintf("mr-out-%d", i)}, // Output file for reduce task
		}
	}

	c.server()
	return &c
}

func generateInputFiles(i int, file int) []string {
	var inputFiles []string

	for j := 0; j < file; j++ {
		inputFiles = append(inputFiles, fmt.Sprintf("mr-%d-%d", j, i))
	}

	return inputFiles
}

type Task int

const (
	Map Task = iota
	Reduce
	Exit
	Wait
)

type Status int

const (
	Unassigned Status = iota
	Assigned
	Finished
)

type MapReduceTask struct {
	Task      Task
	Status    Status
	TimeStamp time.Time
	Index     int

	InputFiles  []string
	OutputFiles []string
}
